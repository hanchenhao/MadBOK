(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{426:function(v,t,_){"use strict";_.r(t);var s=_(54),a=Object(s.a)({},(function(){var v=this,t=v.$createElement,_=v._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"o2o优惠券使用预测"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#o2o优惠券使用预测"}},[v._v("#")]),v._v(" O2O优惠券使用预测")]),v._v(" "),_("h2",{attrs:{id:"业务背景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#业务背景"}},[v._v("#")]),v._v(" 业务背景")]),v._v(" "),_("p",[v._v("O2O是Online To Offline的缩写，其主要分为引流、转化、消费、反馈和留存几个步骤，其核心目标是通过线上运营，将客户引流至线下消费，所以在消费环节商家就会通过线上投放优惠券，希望消费者能够在线下完成消费。")]),v._v(" "),_("p",[v._v("对于商家来讲，投放优惠券是盘活老用户、激活新用户的重要营销手段，优惠券的随机投放会对某些用户造成无意义的干扰，比如给学生投放母婴用品优惠是不合理的，这样不但没有效果还会起到营销的反作用。通过优惠券的精准投放，可以快速的为用户提供精准优惠，也能给商家提供便捷的投放策略，以提高动销效率。")]),v._v(" "),_("h2",{attrs:{id:"思路整理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#思路整理"}},[v._v("#")]),v._v(" 思路整理")]),v._v(" "),_("p",[v._v("根据业务背景，我们希望能够知道用户是否能在规定的时间内使用优惠券，可以从用户的行为梳理一下数据，针对优惠券场景，用户分为线上和线下行为，"),_("strong",[v._v("线下行为有")]),v._v("：领取单未使用优惠券、领取并使用优惠券、消费但使用优惠券。"),_("strong",[v._v("线上行为有")]),v._v("：点击商品、收藏商品、将商品加入购物车、使用优惠券消费、未使用优惠券消费。")]),v._v(" "),_("p",[v._v("线下行为数据：\n"),_("img",{attrs:{src:"https://s3.bmp.ovh/imgs/2023/08/22/fd2654b5362ca704.png",alt:""}})]),v._v(" "),_("p",[v._v("线上行为数据：\n"),_("img",{attrs:{src:"https://s3.bmp.ovh/imgs/2023/08/22/f8256d23f04793e8.png",alt:""}})]),v._v(" "),_("p",[v._v("待预测的数据：\n"),_("img",{attrs:{src:"https://s3.bmp.ovh/imgs/2023/08/22/ec0b5f2d70641aab.png",alt:""}})]),v._v(" "),_("p",[v._v("如果要精准预测用户是否会在规定时间内使用相应的优惠券，就可以基于其线上线下使用消费券的记录和线上获取消费券的记录做一个二分类模型，同时利用本地数据验证模型的准确度。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://s3.bmp.ovh/imgs/2023/08/22/956c49c2ca9b802f.png",alt:""}})]),v._v(" "),_("h2",{attrs:{id:"思路整理-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#思路整理-2"}},[v._v("#")]),v._v(" 思路整理")]),v._v(" "),_("p",[v._v("整体的思路大致为将用户线上线下的消费行为记录进行训练，最终生成一个二分类模型，然后再通过抽样数据对模型质量进行评估，也可以用交叉验证和时间滑窗来进行评估。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://s3.bmp.ovh/imgs/2023/08/24/4d08024687a7cdd3.png",alt:""}})]),v._v(" "),_("p",[v._v("整体的框架思路大致是先通过整理数据源，然后对数据进行分析，通过分析的结果对数据结果形成特征工程，利用特征工程对模型进行训练形成数据模型，最终利用模型融合对训练的数据模型进行调优。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://s3.bmp.ovh/imgs/2023/08/24/85be37a881dd7491.png",alt:""}})]),v._v(" "),_("h2",{attrs:{id:"特征工程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#特征工程"}},[v._v("#")]),v._v(" 特征工程")]),v._v(" "),_("p",[v._v("特征是对一个事物客观属性的描述，从内部看，特征是某些事物的突出性质的表现，从外部看，特征是区分事物的关键。所以，当我们要对事物进行分类或者识别，就是提取特制的过程，通过特征的表现对不同事物进行判断。")]),v._v(" "),_("p",[v._v("比如一个人，他的特征可能是身高173cm，体重75kg，短发，黄皮肤，喜欢运动。在这里就可以对人的性别有一定的区分，可以通过身高、体重以及发型来作为性别较为明显的特征。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://s3.bmp.ovh/imgs/2023/08/26/d2446a52f14c1cbe.png",alt:""}})]),v._v(" "),_("p",[v._v("结合着业务场景我们需要考虑用户特征和商家特征，优惠券方面要考虑优惠券特征和优惠率特征，进一步再看要考虑距离特征和时间特征。当我们有着几个方面的思考了以后，我们就要对数据进行一定的评估。需要评估的标准要考虑如下几点：")]),v._v(" "),_("ul",[_("li",[v._v("测试集与训练集用户的交集")]),v._v(" "),_("li",[v._v("测试集与训练集商家的交集")]),v._v(" "),_("li",[v._v("测试集与训练集优惠券的交集")])]),v._v(" "),_("p",[v._v("特征提取前要做数据预处理，首先要将日期离散化（星期几，节假日，节前，节后）、距离离散化（0-10公里，null）、折扣离散化（满减多少，直接折扣等）。")]),v._v(" "),_("p",[v._v("数据预处理之后，我们就可以先从线下用户特征入手，提取如下内容：")]),v._v(" "),_("ol",[_("li",[v._v("用户领取优惠券次数")]),v._v(" "),_("li",[v._v("用户核销率")]),v._v(" "),_("li",[v._v("用户核销优惠券的平均折扣")]),v._v(" "),_("li",[v._v("用户核销过优惠券的商家数量")]),v._v(" "),_("li",[v._v("用户进行优惠券核销的平均时间")]),v._v(" "),_("li",[v._v("用户核销优惠券的最大商家距离")])]),v._v(" "),_("p",[v._v("线上特征主要表征用户的消费能力，具体如下：")]),v._v(" "),_("ol",[_("li",[v._v("用户线上行为记录数")]),v._v(" "),_("li",[v._v("用户线上点击率")]),v._v(" "),_("li",[v._v("用户线上购买率")]),v._v(" "),_("li",[v._v("用户线上领取率")]),v._v(" "),_("li",[v._v("用户线上核销率")])]),v._v(" "),_("p",[v._v("结合线上线下的特征，我们还可以得出：用户线下记录占总记录的比重，用户线下核销次数占总核销次数的比重等等。")]),v._v(" "),_("p",[v._v("以此类推，商户的特征主要是描述商户受欢迎程度以及商品的被消费规律，特征参考如下：")]),v._v(" "),_("ol",[_("li",[v._v("商户优惠券被领取次数")]),v._v(" "),_("li",[v._v("商户优惠券被核销率")]),v._v(" "),_("li",[v._v("商户优惠券核销的平均折扣率")]),v._v(" "),_("li",[v._v("核销商户优惠券的用户群体数量")]),v._v(" "),_("li",[v._v("商家被核销不同优惠券的数量")]),v._v(" "),_("li",[v._v("商户优惠券被核销的平均时间")]),v._v(" "),_("li",[v._v("商户被核销优惠券中最大用户到往商家的距离")])]),v._v(" "),_("p",[v._v("从上述特征我们还可以进一步探索描述消费规律的日期特征，比如\n星期几消费比较多，节假日的消费潜力如何，节前和节后的消费趋势对比，领券数均值、核销数均值、核销率均值、弃用率均值等等。")]),v._v(" "),_("p",[v._v("为了确定用户对商家的偏好，我们可以利用组合特征来更详细的探寻用户与制定商家优惠券的关系。例如，我们可以统计用户领取（制定商家）优惠券的次数、用户在指定商家的核销率、用户在指定商家核销优惠券的平均折扣、用户在指定商家进行优惠券核销的平均时间等。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://s3.bmp.ovh/imgs/2023/08/26/864f88a91a98e731.png",alt:""}})]),v._v(" "),_("h2",{attrs:{id:"模型构造"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#模型构造"}},[v._v("#")]),v._v(" 模型构造")]),v._v(" "),_("p",[v._v("当前的业务需求可以使用决策树的模型，决策树的想法来自于日常做决策的过程。例如，习惯步行上班的我，早上起来晚上班要迟到了，这时候就面临一个选择，就是是否打车上班，如果第一选择是不想打车，那就要看天气情况怎么样，如果天气好就骑车，天气就不得不打车。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://s3.bmp.ovh/imgs/2023/08/31/4805a2f3a505b039.png",alt:""}})]),v._v(" "),_("p",[v._v("决策树其实就是总结前人经验，然后做具体决策。我们需要通过决策树来挖掘数据里的信息，并总结出规律，以便后续的预测。从另外一个角度来讲，就是要根据这些数据，进行建树。建树需要解决如何建立分支和如何建立子节点两个问题。")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("构建分支")]),v._v("：决策树采用信息增益来衡量一个特征是否重要，而信息增益又是通过信息熵来定义的，信息熵是来描述不稳定程度的，不稳定程度越高，信息熵越大。通过对各种数据特征的信息熵计算，我们可以选择信息增益最大的的特征作为分裂节点。选择第一个分类节点后，再继续按同样的方法进行划分，直到数据被用完、特征被用完或确定性为100%才进行终止。")]),v._v(" "),_("li",[_("strong",[v._v("构建叶子节点")]),v._v("：划分好数据后，可以通过多数投票的方法来决定该叶子节点的值，观察该节点下的数据，取出现最多的标签。")])]),v._v(" "),_("p",[v._v("决策树也有一个毕竟，就是有可能会过拟合，它没办法保证在未知的数据上产生有更强的解释性。GBDT可以用来解决这个问题，GBDT代表梯度提升决策树（Gradient Boosting Decision Trees），是一种机器学习算法，用于回归和分类问题。GBDT通过组合多个决策树模型来构建一个更强大的预测模型。")]),v._v(" "),_("p",[v._v("以下是关于GBDT的一些关键要点：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("梯度提升（Gradient Boosting）")]),v._v("：GBDT的核心思想是通过连续迭代来构建一个强大的预测模型。每一轮迭代都会通过残差纠正前一轮迭代的错误，从而逐渐改善模型的性能。这是通过计算损失函数的负梯度来实现的。")]),v._v(" "),_("li",[_("strong",[v._v("决策树（Decision Trees）")]),v._v("：GBDT的基本模型是决策树。每一轮迭代都会训练一个新的决策树，该树会试图纠正前一轮模型的错误。")]),v._v(" "),_("li",[_("strong",[v._v("集成（Ensemble）")]),v._v("：GBDT是一种集成学习方法，通过组合多个弱模型（决策树）来构建一个强模型。这种集成的方法能够减少过拟合，提高模型的泛化能力。")]),v._v(" "),_("li",[_("strong",[v._v("超参数调整")]),v._v("：GBDT有许多超参数需要调整，包括树的数量、树的深度、学习率等。合适的超参数设置对于模型性能至关重要。")]),v._v(" "),_("li",[_("strong",[v._v("特征重要性")]),v._v("：GBDT可以提供有关输入特征的重要性排序，这有助于理解模型的决策过程和特征的贡献程度。")])]),v._v(" "),_("h2",{attrs:{id:"模型融合"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#模型融合"}},[v._v("#")]),v._v(" 模型融合")]),v._v(" "),_("p",[v._v("模型融合的作用是利用不同模型之间的差异性，来最终提升整体的预测效果。")]),v._v(" "),_("p",[v._v("投票融合（Vote Blend）它的思路是对于一个二分类问题，有N个基础模型，那么就采取投票的方法，投票多者确定为最终分类。如下图所示：")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://s3.bmp.ovh/imgs/2023/09/09/47fed07983775193.png",alt:""}})]),v._v(" "),_("p",[v._v("投票就是基于当前的三个模型结果，少数服从多数，如果有超过半数的模型输出的结果都为1，那投票的结果就视为1，以此类推来确定最终所有内容的投票结果。")]),v._v(" "),_("p",[v._v("加权平均融合（Weight Average）是由N个数据集，训练N个模型，取出N个输出，取出平均值最为最终的结果，如果某些模型比较准确，就可以通过增加某个模型的权重，来影响最终的取值。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://s3.bmp.ovh/imgs/2023/09/09/a9bee2b2205b7760.png",alt:""}})]),v._v(" "),_("p",[v._v("Stacking模型主要是利用k折交叉验证，如下图所示，我们将一个数据集切分成了5份，切分以后，我们将1、2、3、4份的数据作为训练数据，将第5份作为测试数据评估训练模型的好坏，然后再对1、2、3、5份的数据进行训练，将第4份的数据作为模型评估，以此类推，最终根据不同的评估结果取一个均值。这种方式对所有数据集都进行了评估，结果相对准确。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://s3.bmp.ovh/imgs/2023/09/09/b9078b0d8340791f.png",alt:""}})]),v._v(" "),_("p",[_("img",{attrs:{src:"https://s3.bmp.ovh/imgs/2023/09/09/1c9b48ac6204b791.png",alt:""}})]),v._v(" "),_("p",[_("img",{attrs:{src:"https://s3.bmp.ovh/imgs/2023/09/09/c277eb1238dd857b.png",alt:""}})]),v._v(" "),_("p",[v._v("stacking本质上是一种分层模型，它首先让我们使用不同的算法或者其他方法能够训练出多个不同的模型，然后将这些模型的输出作为新的数据集，然后将这些模型的输出再作为为输入训练的一个模型，最后得到一个最终的结果并进行输出。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://s3.bmp.ovh/imgs/2023/09/09/a20c5dcc91c88509.png",alt:""}}),v._v(" "),_("img",{attrs:{src:"https://s3.bmp.ovh/imgs/2023/09/09/f6401b3941edd09a.png",alt:""}}),v._v(" "),_("img",{attrs:{src:"https://s3.bmp.ovh/imgs/2023/09/09/0c53ab5c94d614a4.png",alt:""}})]),v._v(" "),_("p",[_("img",{attrs:{src:"https://s3.bmp.ovh/imgs/2023/09/09/bfdf12e20a71eed8.png",alt:""}})]),v._v(" "),_("p",[_("img",{attrs:{src:"https://s3.bmp.ovh/imgs/2023/09/09/a12842c5d9b19e76.png",alt:""}})]),v._v(" "),_("h2",{attrs:{id:"auc评估"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#auc评估"}},[v._v("#")]),v._v(" AUC评估")]),v._v(" "),_("p",[v._v("AUC（Area Under the Curve）是一种常用于评估机器学习模型性能的指标之一，特别在二分类问题中常被用到。AUC是ROC曲线（Receiver Operating Characteristic Curve）下的面积，而ROC曲线是一种用于可视化二分类模型性能的工具。")]),v._v(" "),_("p",[v._v("在AUC评估中，首先需要计算模型的ROC曲线，ROC曲线是以真正例率（True Positive Rate，也叫敏感度或召回率）为纵坐标，假正例率（False Positive Rate）为横坐标绘制的曲线。ROC曲线描述了在不同阈值下模型的性能表现，阈值是用来将模型的输出概率转换为二分类预测结果（正类别或负类别）的数值。")]),v._v(" "),_("p",[v._v("AUC值表示了ROC曲线下方的面积大小，其取值范围在0到1之间。一个完美的分类器的AUC等于1，而一个随机猜测的分类器的AUC等于0.5。通常来说，AUC越接近1，模型的性能越好。")]),v._v(" "),_("p",[v._v("AUC的优点包括对于类别不平衡问题的鲁棒性，它不受正负样本比例的影响。因此，AUC常常被用来评估二分类模型在不同应用场景下的性能，尤其是在涉及到诸如医疗诊断、信用评分、垃圾邮件检测等领域的任务中。")])])}),[],!1,null,null,null);t.default=a.exports}}]);
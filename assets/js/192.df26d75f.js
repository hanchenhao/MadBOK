(window.webpackJsonp=window.webpackJsonp||[]).push([[192],{577:function(t,v,_){"use strict";_.r(v);var s=_(54),r=Object(s.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"解决方案架构性能设计"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#解决方案架构性能设计"}},[t._v("#")]),t._v(" 解决方案架构性能设计")]),t._v(" "),_("h2",{attrs:{id:"解决方案架构性能的设计原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#解决方案架构性能的设计原则"}},[t._v("#")]),t._v(" 解决方案架构性能的设计原则")]),t._v(" "),_("p",[t._v("架构的性能效率主要侧重如何通过有效使用应用程序的基础设施和资源，来满足日益增长的需求和技术评估的需要。如下是工作负载性能优化需要考虑的一些重要设计原则：")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("降低延迟")]),t._v("。延迟是指用户发送请求到所需响应之间的时间延迟，应用程序发布在互联网上，数据通过网络发送到另一个地方响应时间，网络延迟可能是由传输介质、路由器跃点、网络传播等异常情况造成，可以使用光纤线路来建立企业网络连接，在基础设施层面，计算服务器可能会因为内存和处理器问题而出现延迟，磁盘可能会新闻读写缓慢延迟，在数据库层面，可以通过分区和分片来分配数据，从而减轻数据库负载降低延迟。")]),t._v(" "),_("li",[_("strong",[t._v("提高吞吐量")]),t._v("。吞吐量是指在给定时间发送和接收的数据量，吞吐量和延迟有直接关系，它们是此消彼长的，低延迟意味着高吞吐量。在数据层层面，吞吐量由数据库每秒可以处理的事务决定，在应用程序层面，代码需要通过垃圾回收处理和内存缓存来管理应用程序内存，从而处理每秒发生的事务。")]),t._v(" "),_("li",[_("strong",[t._v("处理并发问题")]),t._v("。并发是指应用程序通过线程之间的共享资源来同时处理多个任务，共享内存并发模型有助于实现并发处理，在这个模型中，并发模块间使用共享内存进行交互，它们共享可以读写的文件系统，还可以共享相同的内存。")]),t._v(" "),_("li",[_("strong",[t._v("使用缓存")]),t._v("。使用缓存可以显著提高应用程序性能，在服务器层面，CPU具备硬件缓存，其包含指令缓存和数据缓存，数据缓存存储常用的数据副本。数据库具备内部缓存，会根据不同的使用方式，在缓存中准备好数据，如果我们对某个查询执行了多次，它会将结果保存在查询缓存中。网络层面有DNS缓存，它将域名和对应的IP地址存储在服务器本地，我们在访问同一个页面时，可以进行快速的查询。")])]),t._v(" "),_("h2",{attrs:{id:"性能优化的技术选型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#性能优化的技术选型"}},[t._v("#")]),t._v(" 性能优化的技术选型")]),t._v(" "),_("p",[t._v("性能优化是一个持续改进的过程，从方案设计到应用发布，都要追求最佳的资源利用率，需要根据工作负载选择合适的资源，或者调整应用程序的基础设施的配置。我们需要针对主要的资源类型进行具体的技术选型：")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("计算能力选型")]),t._v("。根据工作负载的不同，可以选择CPU、GPU、FPGA、ASIC等处理单元，从性能上看，ASIC的效率最高，但是需要更长的开发周期来实现，CPU最灵活且使用范围更广。GPU主要适用于计算密集型应用，FPGA可以作为应用性能定制时的首选。")]),t._v(" "),_("li",[_("strong",[t._v("容器选型")]),t._v("。利用容器已经成为部署微服务应用的标准，Docker允许应用程序及其相关的依赖项打包为容器，并部署到任意操作系统平台，可以使用Docker Hub或云托管服务来管理和分发容器镜像，复杂的企业应用可能会横跨多个容器的微服务来进行构建，可以使用K8s来应对多环境的挑战，K8s是容器编排系统，它可以对跨节点的集群进行协调和编排，并通过替换无响应的容器来实现应用程序的自我恢复。K8s不但可以提供水平伸缩和蓝绿部署功能，还能通过主节点分配IP地址，并提供键值对存储来保存容器配置，通过Kubelet管理容器。K8s比较复杂。可以使用Amazon EKS或红帽的OpenShift来简化K8s的集群管理。")]),t._v(" "),_("li",[_("strong",[t._v("无服务化应用选型")]),t._v("。无服务器计算可以让开发人员专注与代码和应用程序开发，无须关心基层基础设施的配置和伸缩性。无服务话适合调度作业、处理网络请求或队列消息处理。")]),t._v(" "),_("li",[_("strong",[t._v("存储选型")]),t._v("。由于访问方法（块、文件或对象）、访问模式（顺序或随机）、访问频率（在线、离线、归档）、更新频率（一次写多次读或动态更新）、访问吞吐量、访问持久性的不同，存储的选型方案也会不尽相同。当应用程序需要由单个实例提供数据访问，还要求非常低的延迟时，应使用块存储。当单独的应用需要访问多个实例时，应该使用文件存储系统。使用对象存储来存储和访问静态内容，例如图像和视频，也可以在对象存储中存储大量数据，并进行大数据处理和分析。")]),t._v(" "),_("li",[_("strong",[t._v("数据库选型")]),t._v("。传统关系型数据库大多被认为是在线事务处理型（OLTP）的，其数据访问模式包括通过查找ID来获取最小数据集，关系模型允许在应用程序中处理复杂的业务关系，能够聚合数据，并跨表创建复杂查询，但是需要汇总和查询海量数据时，OLTP会出现性能瓶颈，另外关系型数据库也不能处理非结构化数据。如物联网数据和日志这种非结构化数据，因为记录的结构不想同，所以可以使用NoSQL数据库来灵活存储此类数据，它可以无须担心结构问题，每条记录具有可变数量的列，并且存储在同一张表中，但是NoSQL不支持复杂查询，大规模分析的功能也十分有限。为了快速访问结构化数据而设计的数据仓库平台可以更好地满足对大量结构化数据进行分析和查询的需求，现代是数据仓库采用列式存储，这样可以避免对整张表进行扫描，通过减少扫描的数据库，从而提高性能。在搜索数据的时候，我们也可以用类似Elasticsearch等搜索引擎平台。")]),t._v(" "),_("li",[_("strong",[t._v("网络选型")]),t._v("。网络选型方案取决与网络速度、吞吐量和网络延迟要求。可以采用不同的路由策略来连接可用服务器，利用负载均衡器在服务器之间分配网络流量，负载均衡器可以根据数据包头的信息和数据包完整内容进行路由。")])]),t._v(" "),_("h2",{attrs:{id:"管理性能监控"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#管理性能监控"}},[t._v("#")]),t._v(" 管理性能监控")]),t._v(" "),_("p",[t._v("当我们试图主动了解性能问题并减少对终端用户的影响时，性能监控至关重要。应该定义性能基准，并在阈值被突破的情况下向团队发出告警，例如，应用程序的移动端应用打开时间不应超过3秒。发出告警时应该能够触发自动操作，以处理性能不佳的组件，例如，在Web应用集群中增加节点以降低请求负载。")]),t._v(" "),_("p",[_("strong",[t._v("监控方案可分为主动监控和被动监控两种：")])]),t._v(" "),_("ul",[_("li",[t._v("主动监控需要模拟用户的活动，并提前识别可能的性能问题。应用程序的数据和工作负载情况总是在变化，这就需要持续的主动监控，应该在所有的开发、测试和生产环境中运行主动监控，以便在问题影响用户之前就能够被发现")]),t._v(" "),_("li",[t._v("被动监控试图实时识别某种未知状况。对于Web应用程序来说，被动监控需要从浏览器中收集可能导致性能问题的重要指标。可以从用户那里收集有关他们的地理位置、浏览器类型和设备类型的指标，以了解用户体验和应用程序在不同地理位置的性能。监控的一切都是基于数据的，它包括大量数据的提取、处理和可视化。")])]),t._v(" "),_("p",[t._v("高性能总是伴随着高成本，我们需要考虑如何取舍，以选择正确的方法，根据应用程序需求，你可以在持久性、一致性、成本和性能之间进行权衡。")])])}),[],!1,null,null,null);v.default=r.exports}}]);
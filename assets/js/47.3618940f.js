(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{433:function(v,_,t){"use strict";t.r(_);var a=t(54),s=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"机器学习的经典算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#机器学习的经典算法"}},[v._v("#")]),v._v(" 机器学习的经典算法")]),v._v(" "),t("h2",{attrs:{id:"线性回归算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线性回归算法"}},[v._v("#")]),v._v(" 线性回归算法")]),v._v(" "),t("p",[v._v("线性回归是利用数学统计中回归分析，来确定两种或两种以上变量相互依赖定量关系的一种统计方法。线性回归是机器学习中最基本的回归算法之一，用于预测一个连续的输出变量（因变量）和一个或多个输入变量（自变量）之间的线性关系。简单线性回归模型中只有一个输入变量，而多元线性回归模型中有多个输入变量。")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://s3.bmp.ovh/imgs/2023/05/31/fed3a7a32b0a9bc2.png",alt:""}})]),v._v(" "),t("p",[v._v("线性回归算法的主要思想是找到一条直线（或超平面），使得所有输入变量和输出变量之间的误差最小化。这个误差可以用最小二乘法来计算，即将所有误差的平方和最小化。这条直线（或超平面）被称为最佳拟合线（或超平面），它可以用以下公式表示：")]),v._v(" "),t("p",[t("code",[v._v("y = b0 + b1*x1 + b2*x2 + ... + bn*xn")])]),v._v(" "),t("p",[v._v("其中，y是输出变量，x1, x2, ..., xn是输入变量，b0, b1, b2, ..., bn是回归系数，它们是通过最小化误差平方和来计算得出的。")]),v._v(" "),t("p",[v._v("线性回归算法的优点是简单易懂、易于实现、计算速度快，适用于解决许多实际问题。但是，它也有一些缺点，例如对于非线性关系的数据拟合效果不佳，容易受到异常值的影响等。在实际应用中，可以使用各种工具和库来实现线性回归算法，例如Python中的scikit-learn库、R语言中的lm函数等。")]),v._v(" "),t("p",[v._v("通常会用"),t("strong",[v._v("过拟合与欠拟合")]),v._v("来度量模型泛化能力的直观表现。过拟合是指在训练集上表现很好，到了验证和测试阶段就表现很差，欠拟合是指模型在训练集和测试集均表现不佳的情况。")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://s3.bmp.ovh/imgs/2023/05/31/043f0fe7c12306c3.png",alt:""}})]),v._v(" "),t("p",[v._v("为了解决线性回归模型在面对高维数据时容易过拟合的问题，可以在线性回归的基础上加入正则化模型，通过加入正则化项来限制模型的复杂度，从而提高模型的泛化能力。")]),v._v(" "),t("p",[v._v("回归正则化模型有两种形式：L1正则化和L2正则化。L1正则化也叫Lasso回归，它的正则化项是回归系数的绝对值之和，可以使得一些回归系数变为0，从而实现特征选择的功能。L2正则化也叫Ridge回归，它的正则化项是回归系数的平方和，可以使得回归系数变得较小，但不会变为0。")]),v._v(" "),t("p",[v._v("在回归正则化模型中，模型的目标函数不仅包括最小化预测值和真实值之间的误差，还包括正则化项。目标函数可以表示为：")]),v._v(" "),t("p",[v._v("L = (y - Xw)^T(y - Xw) + λ*||w||^2")]),v._v(" "),t("p",[v._v("其中，y是真实值，X是输入变量，w是回归系数，λ是正则化系数，||w||^2是回归系数的平方和或绝对值之和，取决于使用的是L1正则化还是L2正则化。")]),v._v(" "),t("p",[v._v("正则化系数λ越大，模型的正则化效果就越强，回归系数就越小，模型的复杂度就越低，但是模型的拟合能力也会降低。正则化系数λ越小，模型的正则化效果就越弱，回归系数就越大，模型的复杂度就越高，但是模型的拟合能力也会更好。")]),v._v(" "),t("p",[v._v("回归正则化模型可以通过梯度下降等优化算法求解，也可以使用各种机器学习库和工具来实现，例如Python中的scikit-learn库、R语言中的glmnet包等。")]),v._v(" "),t("h2",{attrs:{id:"逻辑回归算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#逻辑回归算法"}},[v._v("#")]),v._v(" 逻辑回归算法")]),v._v(" "),t("p",[v._v("逻辑回归是一种监督学习算法，主要用于二元分类问题。其基本思想是，通过对输入特征进行线性组合，得到一个预测值，然后通过一个sigmoid函数将预测值映射到[0,1]之间，表示属于某一类别的概率。sigmoid函数的公式为：")]),v._v(" "),t("p",[v._v("sigma(z) = \\frac{1}{1 + e^{-z}}")]),v._v(" "),t("p",[v._v("其中z为输入特征的线性组合，可以表示为：")]),v._v(" "),t("p",[v._v("z = w0 + w"),t("em",[v._v("1x1 + w2")]),v._v("x2 + ... + wn*xn")]),v._v(" "),t("p",[v._v("其中，w0为偏置项，w1到wn为权重参数，x1到xn为输入特征。")]),v._v(" "),t("p",[v._v("逻辑回归的训练过程是通过最大化似然函数来实现的。似然函数表示观察到给定数据的概率，即给定特征向量$x$，属于类别$y$的概率为：")]),v._v(" "),t("p",[v._v("P(y|x) = sigma(yz)^y(1-\\sigma(yz))^{1-y}")]),v._v(" "),t("p",[v._v("其中，z为输入特征的线性组合，y为类别标签，P(y|x)表示在给定输入特征x的情况下，属于类别y的概率。")]),v._v(" "),t("p",[v._v("逻辑回归还可以用于多分类问题，主要一对一、一对多(OvA)和多项式逻辑回归。OvA方法将多分类问题转化为多个二元分类问题，每次将一个类别作为正例，其余类别作为反例，训练多个模型。多项式逻辑回归则直接将多个类别的概率进行建模，输出每个类别的概率。")]),v._v(" "),t("p",[v._v("一对一法是指对K分类，训练时依次让不同类别数据两两组合训练，得到K*(K-1)/2个二分类模型，预测时分别用二分类器进行预测，最后得票最多的类别即为未知样本的类别。其优点是能够一定程度规避数据不平衡情况，性能相对稳定，训练效率高，缺点是训练的二分类模型多，影响预测时间。")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://s3.bmp.ovh/imgs/2023/05/31/0bf26c3429348c1b.png",alt:""}})]),v._v(" "),t("p",[v._v("一对多法是指对K分类，训练时依次把某个类别的样本归为一类，其他剩余的样本归为另一类，得到K个分类器，预测时分别用K个分类器进行预测，选择结果最大的作为分类的结果。其优点是普适性较广、效率较高，缺点是易造成数据不平衡。")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://s3.bmp.ovh/imgs/2023/05/31/73204905c02a3e5f.png",alt:""}})]),v._v(" "),t("p",[v._v("多项式逻辑回归是一种用于多分类问题的逻辑回归算法。与一对多法不同的是，多项式逻辑回归直接将多个类别的概率进行建模，输出每个类别的概率。具体来说，对于一个K分类问题，多项式逻辑回归会学习K个线性模型，每个模型对应一个类别。对于第k个类别，其模型为：")]),v._v(" "),t("p",[v._v("P(y=k|x) = \\frac{e^{w_k^Tx}}{\\sum_{j=1}^K e^{w_j^Tx}}")]),v._v(" "),t("p",[v._v("其中，w_k为第k个类别的权重参数，x为输入特征，P(y=k|x)表示在给定输入特征x的情况下，属于第k个类别的概率。")]),v._v(" "),t("p",[v._v("多项式逻辑回归的训练过程是通过最大化似然函数来实现的。似然函数表示观察到给定数据的概率，即给定特征向量x，属于类别$y$的概率为：")]),v._v(" "),t("p",[v._v("P(y|x) = \\prod_{k=1}^K P(y=k|x)^{[y=k]}")]),v._v(" "),t("p",[v._v("其中，[y=k]为指示函数，表示如果y=k，则为1，否则为0。")]),v._v(" "),t("p",[v._v("多项式逻辑回归的预测过程是将输入特征x带入到K个线性模型中，计算每个类别的概率，然后选择概率最大的类别作为分类结果。多项式逻辑回归的优点是能够直接输出每个类别的概率，对于不平衡数据集的处理效果较好。缺点是需要训练K个模型，计算开销较大。")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://s3.bmp.ovh/imgs/2023/05/31/dc09e9242bca45e0.png",alt:""}})]),v._v(" "),t("p",[v._v("逻辑回归的应用非常广泛，如广告点击率预测、信用评分、疾病诊断等领域。多分类逻辑回归的应用也非常广泛，如手写数字识别、图像分类等领域。")]),v._v(" "),t("h2",{attrs:{id:"朴素贝叶斯算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#朴素贝叶斯算法"}},[v._v("#")]),v._v(" 朴素贝叶斯算法")]),v._v(" "),t("p",[v._v("朴素贝叶斯算法是一种基于贝叶斯定理的分类算法，它假设所有特征之间相互独立，因此被称为“朴素”。该算法在分类问题中广泛应用，特别是在文本分类、垃圾邮件过滤、情感分析、推荐系统等领域。该算法的基本思想是，对于给定的数据集，首先计算每个类别的先验概率，然后计算每个特征在各个类别下的条件概率，最后根据贝叶斯定理计算后验概率，从而确定最可能的分类结果。")]),v._v(" "),t("p",[v._v("朴素贝叶斯算法是一种基于贝叶斯定理的分类算法，它假设所有特征之间相互独立，因此被称为“朴素”。该算法在分类问题中广泛应用，特别是在文本分类、垃圾邮件过滤、情感分析、推荐系统等领域。")]),v._v(" "),t("p",[v._v("朴素贝叶斯算法的原理是基于贝叶斯定理，即在已知某个样本属于某个类别的前提下，通过计算其他特征对该样本属于不同类别的概率进行分类。具体来说，朴素贝叶斯算法的步骤如下：")]),v._v(" "),t("ol",[t("li",[v._v("计算每个类别的先验概率，即在没有任何特征信息的情况下，样本属于每个类别的概率。")]),v._v(" "),t("li",[v._v("对于每个特征，计算在每个类别下的条件概率，即样本属于某个类别，并且该特征出现的概率。")]),v._v(" "),t("li",[v._v("根据贝叶斯定理计算后验概率，即在已知样本的特征信息的前提下，样本属于每个类别的概率。")]),v._v(" "),t("li",[v._v("根据后验概率确定最可能的分类结果。")])]),v._v(" "),t("p",[v._v("在实际应用中，朴素贝叶斯算法通常需要进行数据预处理，包括数据清洗、特征选择、特征提取等。常用的朴素贝叶斯算法包括多项式朴素贝叶斯、伯努利朴素贝叶斯和高斯朴素贝叶斯等。")]),v._v(" "),t("p",[v._v("多项式朴素贝叶斯算法适用于离散特征，伯努利朴素贝叶斯算法适用于二元特征，而高斯朴素贝叶斯算法适用于连续特征。在实际应用中，可以根据不同的数据类型和应用场景选择不同的朴素贝叶斯算法。")]),v._v(" "),t("p",[t("strong",[v._v("朴素贝叶斯算法的应用非常广泛，例如")]),v._v("：")]),v._v(" "),t("ol",[t("li",[v._v("文本分类：可以用于对文本进行分类，如对新闻文章进行分类，自动将其分类为体育、政治、经济等不同的类别。")]),v._v(" "),t("li",[v._v("垃圾邮件过滤：可以用于对邮件进行分类，自动将其分类为垃圾邮件或正常邮件。")]),v._v(" "),t("li",[v._v("推荐系统：可以用于对用户进行分类，自动将其分类为对某个产品感兴趣或不感兴趣。")]),v._v(" "),t("li",[v._v("情感分析：可以用于对文本进行情感分类，自动将其分类为正面、负面或中性情感。")]),v._v(" "),t("li",[v._v("医学诊断：可以用于对患者进行分类，自动将其分类为患有某种疾病或健康。")])]),v._v(" "),t("p",[v._v("垃圾邮件过滤是朴素贝叶斯算法的一个经典应用场景。下面是一种基于朴素贝叶斯算法的垃圾邮件过滤的实现步骤：")]),v._v(" "),t("ol",[t("li",[v._v("数据预处理：将邮件文本进行分词，去除停用词和标点符号，将每个单词作为特征。")]),v._v(" "),t("li",[v._v("特征提取：统计训练集中每个单词在垃圾邮件和非垃圾邮件中出现的次数，以及垃圾邮件和非垃圾邮件的数量。")]),v._v(" "),t("li",[v._v("计算概率：根据朴素贝叶斯算法，计算每个单词在垃圾邮件和非垃圾邮件中出现的概率，以及垃圾邮件和非垃圾邮件的概率。")]),v._v(" "),t("li",[v._v("邮件分类：对于新的邮件，将其分词后计算每个单词在垃圾邮件和非垃圾邮件中出现的概率，然后根据贝叶斯公式计算该邮件是垃圾邮件的概率。如果概率大于某个阈值，则将其分类为垃圾邮件，否则分类为非垃圾邮件。")]),v._v(" "),t("li",[v._v("模型评估：使用测试集对模型进行评估，计算准确率、召回率、F1值等指标。")])]),v._v(" "),t("p",[v._v("需要注意的是，在实际应用中，还需要考虑一些其他的问题，比如数据不平衡、过拟合等。可以通过调整模型参数、采用交叉验证等方法来解决这些问题。")]),v._v(" "),t("h2",{attrs:{id:"k近邻算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#k近邻算法"}},[v._v("#")]),v._v(" K近邻算法")]),v._v(" "),t("p",[v._v("KNN算法（K-Nearest Neighbors）是一种常见的机器学习算法，它是一种基于实例的学习方法，用于分类和回归问题。KNN算法的基本思想是：对于一个新的数据点，找出与其距离最近的K个训练数据点，然后根据这K个数据点的类别（或者数值）来预测该数据点的类别（或者数值）。其中，K是一个正整数，通常由用户指定。")]),v._v(" "),t("p",[v._v("在KNN算法中，距离通常使用欧氏距离或曼哈顿距离等来计算。对于分类问题，KNN算法通常使用多数表决的方式来决定预测结果；对于回归问题，KNN算法通常使用平均值的方式来计算预测结果。欧氏距离和曼哈顿距离都是用于计算数据点之间的距离或相似度的常用指标。它们的计算方式如下：")]),v._v(" "),t("p",[t("strong",[v._v("欧氏距离")])]),v._v(" "),t("p",[v._v("欧氏距离是指在欧几里得空间中，两个点之间的距离。对于两个n维向量a和b，欧氏距离的计算公式为：d(a,b) = sqrt((a1-b1)^2 + (a2-b2)^2 + ... + (an-bn)^2)")]),v._v(" "),t("p",[v._v("其中，a1、a2、...、an和b1、b2、...、bn是向量a和b的各个维度的取值。")]),v._v(" "),t("p",[t("strong",[v._v("曼哈顿距离")])]),v._v(" "),t("p",[v._v("曼哈顿距离是指在城市街区中，两点之间沿着网格线走的距离。对于两个n维向量a和b，曼哈顿距离的计算公式为：d(a,b) = |a1-b1| + |a2-b2| + ... + |an-bn|")]),v._v(" "),t("p",[v._v("其中，|ai-bi|表示向量a和b在第i维上的差的绝对值。这两种距离度量方法都可以用于计算数据点之间的距离或相似度，但在不同的应用场景下可能会有不同的表现效果。")]),v._v(" "),t("p",[v._v("KNN是一种基于实例的学习方法，它可以用于分类和回归问题。KNN分类算法是指对于一个未知类别的数据点，通过计算其与已知类别数据点之间的距离，找到离它最近的k个数据点，然后根据这k个数据点所属的类别，来预测该未知数据点的类别。这里的k是一个预先设定的参数，通常选择一个奇数，以便在出现平局时能够进行投票。")]),v._v(" "),t("p",[v._v("KNN回归算法则是指对于一个未知的数值型数据点，通过计算其与已知数值型数据点之间的距离，找到离它最近的k个数据点，然后根据这k个数据点的数值，来预测该未知数据点的数值。这里的k也是一个预先设定的参数。")]),v._v(" "),t("p",[v._v("KNN岭回归是KNN回归的一种改进算法，它在计算距离时加入了一个岭项，以防止数据过拟合。具体来说，岭回归在计算距离时，会将距离乘以一个权重系数，这个权重系数是一个与距离成反比的函数，并且在距离较小时取值较大，在距离较大时取值较小。这样可以使得距离近的数据点在预测中占据更大的权重，从而提高预测的准确性。")]),v._v(" "),t("p",[v._v("总的来说，KNN分类和KNN回归都是基于距离的算法，它们的核心思想是通过寻找最近邻的数据点来进行预测。而KNN岭回归则是在KNN回归的基础上加入了一个岭项，以防止数据过拟合。")]),v._v(" "),t("p",[v._v("KNN算法的优点是简单易懂、易于实现，适用于各种类型的数据；缺点是计算量大，对于高维数据和大规模数据集，计算复杂度较高。")]),v._v(" "),t("p",[t("strong",[v._v("KNN算法的应用非常广泛，例如")]),v._v("：")]),v._v(" "),t("ol",[t("li",[v._v("图像分类：使用KNN算法对图像进行分类，可以识别出不同的物体、场景等。")]),v._v(" "),t("li",[v._v("推荐系统：使用KNN算法对用户进行分类，可以推荐相似兴趣的用户所喜欢的物品。")]),v._v(" "),t("li",[v._v("信用评估：使用KNN算法对客户进行分类，可以预测客户的信用状况。")]),v._v(" "),t("li",[v._v("医学诊断：使用KNN算法对病人进行分类，可以预测病人的病情和治疗方案。")]),v._v(" "),t("li",[v._v("语音识别：使用KNN算法对语音进行分类，可以识别不同的语音信号。")])]),v._v(" "),t("h2",{attrs:{id:"支持向量机算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#支持向量机算法"}},[v._v("#")]),v._v(" 支持向量机算法")]),v._v(" "),t("p",[v._v("支持向量机（Support Vector Machine，SVM）是一种常用的监督学习算法，主要用于分类和回归问题。其基本思想是将数据映射到高维空间中，使得在该空间中可以找到一个最优的超平面，将不同类别的数据点分开。SVM算法的优点在于可以处理高维数据，并且在处理非线性分类问题时表现良好。")]),v._v(" "),t("p",[v._v("SVM算法的基本思想是将数据点映射到高维空间中，并在该空间中寻找一个最优的超平面，将不同类别的数据点分开。在二分类问题中，SVM算法的目标是找到一个最优的超平面，使得两个类别的数据点到该超平面的距离最大化。这个距离被称为间隔（margin），而最大化间隔的超平面被称为最优超平面。在实际应用中，由于数据点往往不是线性可分的，因此需要使用一些技巧来将数据点映射到高维空间中，使得它们在该空间中能够被线性分开。")]),v._v(" "),t("p",[v._v("SVM算法的核心是求解最优化问题，即在给定的数据集上，找到一个最优的超平面，使得分类误差最小，并且间隔最大。这个问题可以转化为一个二次规划问题，并通过拉格朗日乘子法进行求解。具体来说，SVM算法通过求解一组拉格朗日乘子来得到最优超平面，这些拉格朗日乘子可以用来表示数据点的重要性。在求解过程中，只有一部分数据点对最优超平面有贡献，这些数据点被称为支持向量，而其他数据点则不起作用。")]),v._v(" "),t("p",[v._v("在SVM算法中，有几个重要的参数需要进行调整。其中最重要的是核函数的选择，核函数用于将数据点映射到高维空间中，常用的核函数包括线性核、多项式核和高斯核等。另外，还需要调整正则化参数C的取值，C的取值越小，对误分类的惩罚越小，容错率越高，反之则容错率越低。此外，还有一些其他的参数需要进行调整，如多项式核的阶数、高斯核的带宽等。")]),v._v(" "),t("p",[v._v("总的来说，SVM算法是一种常用的监督学习算法，它通过将数据点映射到高维空间中，寻找一个最优的超平面，将不同类别的数据点分开。SVM算法的核心是求解最优化问题，并且需要调整一些重要的参数。")]),v._v(" "),t("h2",{attrs:{id:"集成学习算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#集成学习算法"}},[v._v("#")]),v._v(" 集成学习算法")]),v._v(" "),t("p",[v._v("机器学习中的集成算法是一种将多个基本模型组合起来来提高预测准确性的方法。它的基本思想是，通过将多个弱分类器组合成一个强分类器，以提高整体分类准确率。集成算法通常可以分为：bagging、boosting和stacking。")]),v._v(" "),t("p",[v._v("Bagging算法是一种基于自助采样技术的集成算法。其主要对样本训练集合进行随机化抽样，通过反复抽样训练新的模型，最终在这些模型的基础上取平均。它的基本思想是通过在原始数据集中随机抽取一定数量的样本，形成多个新的训练数据集，然后分别训练多个基本分类器，并将它们的结果进行投票或平均来得到最终的分类结果。常见的Bagging算法包括随机森林(Random Forest)和Extra-Trees。")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://s3.bmp.ovh/imgs/2023/06/01/19926ec88c1d71f5.png",alt:""}})]),v._v(" "),t("p",[v._v("Boosting算法是一种基于序列学习技术的集成算法。其通过不断地使用一个弱学习弥补前一个弱学习的不足的过程，来串行地构造一个较强的学习器，这个强学习器能够使目标函数值足够小。它的基本思想是通过训练多个基本分类器，每个基本分类器都在前一个分类器的误差上进行改进，最终将它们组合成一个强分类器。常见的Boosting算法包括AdaBoost、Gradient Boosting和XGBoost。")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://s3.bmp.ovh/imgs/2023/06/01/2fd0dc9128984b2c.png",alt:""}})]),v._v(" "),t("p",[v._v("除了Bagging和Boosting算法之外，还有一种集成算法叫做Stacking。Stacking是通过一个元分类器或者元回归器来整合多个分类模型或回归模型的集成学习技术，基础模型利用整个训练集做训练，元模型将基础模型的输出作为特征进行训练。基础模型利用整个训练集做训练，元模型将基础模型的特征作为特征进行训练。它的基本思想是将多个基本分类器的输出作为输入，训练一个元分类器来组合它们的结果。Stacking算法通常需要进行交叉验证来避免过拟合。")]),v._v(" "),t("p",[v._v("Stacking算法的核心思想是将多个基本分类器的输出作为元特征来训练元分类器，以提高整体的预测准确率。在实践中，我们可以使用不同的基本分类器和元分类器来进行尝试，并根据实验结果选择最优的组合。")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://s3.bmp.ovh/imgs/2023/06/01/0942c08c54050b5f.png",alt:""}})]),v._v(" "),t("p",[v._v("总的来说，集成算法可以显著提高机器学习模型的预测准确率和鲁棒性。但是，它也有一些缺点，例如训练时间长、模型复杂度高等。因此，在使用集成算法时需要根据具体情况进行权衡和选择。")])])}),[],!1,null,null,null);_.default=s.exports}}]);